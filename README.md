# курс РАГИС@ФМИ на СУ
# Задача: Отсяване на данни за София и въвеждане в СУБД

## Контекст
Този проект има за цел да внесе в нашата СУБД геометрии за сгради в България, предоставени във формат GeoJSONL, в пространствена база данни PostgreSQL/PostGIS. Данните са изтеглени от глобален публичен източник и са организирани по квадрати (quadkey) за територията на България. Интересува ни територията на София.

## Основни стъпки

1. **Създаване на таблица**: Създава се таблица `bulgaria_buildings` с геометрия (Polygon, EPSG:7801) и указател (индекс) за по-бързо пространствено търсене.
2. **Използване на административни граници**: Използва се `adm_rayoni`, която съдържа административни райони. Полезни данни за подбора на пространствени данни, отнасящи се само за сгради в София.
3. **Внос на данни**: Програмата `import_sofia_buildings.py`:
   - Чете ред по ред GeoJSONL файловете от папка `IN/`. Те са компресирани, за това ги разкомпресира в движение с модула gzip.
   - За всяка сграда проверява дали попада в границите на София (като обвивка) и ако да:
      - Се въвеждат одобрените сгради в базата данни.

## Алгоритъм 

1.  **Настройка на средата:** Зареждане на детайли за връзка с базата данни от `.env` файл, намиращ се в родителската директория.
2.  **Входни файлове:** Сканиране на поддиректорията `lab01/IN/` за всички `.gz` файлове, съдържащи GeoJSONL данни. Прекратяване, ако не са намерени файлове.
3.  **Връзка с базата данни:** Установяване на връзка с PostgreSQL базата данни, използвайки данните от `.env` файла.
4.  **Изчисляване на граница:**
    *   Свързване с базата данни.
    *   Изпълнение на SQL заявка към таблицата `adm_rayoni` (дефинирана от `source_boundary_table`), за да се:
        *   Буферират леко геометриите (`ST_Buffer(geom, 0.1)`).
        *   Обединят в една геометрия (`ST_Union`).
        *   Опрости полученото обединение (`ST_Simplify(..., 100)`).
        *   **Трансформира резултата директно в EPSG:7801 (`ST_Transform(..., 7801)`)**.
        *   Извлече резултатът като Well-Known Text (WKT).
    *   Зареждане на WKT в Shapely обект-геометрия чрез `shapely.wkt.loads`.
    *   Задаване на Spatial Reference ID (SRID) на геометрията на границата на **EPSG:7801** чрез `shapely.set_srid`.
    *   Ако изчисляването на границата е неуспешно, скриптът се прекратява.
5.  **Обработка на данни (Цикъл през всеки `.gz` файл):**
    *   Записване на началното време за файла.
    *   Отваряне на `.gz` файла за четене в двоичен режим.
    *   **Във функцията `process_and_insert_data`:**
        *   Създаване на `pyproj.Transformer` за конвертиране на координати от EPSG:4326 към EPSG:7801.
        *   **Итерация през всеки ред (обект) във файла:**
            *   Прочитане, декодиране и обръщане на входния ред към JSON обект. Ползваме `geometry` полето от JSON обекта.
            *   Проверка дали геометрията съществува и нейният `type` е 'Polygon'.
            *   **Ако е 'Polygon':**
                *   Конвертиране на GeoJSON геометрията в Shapely обект-геометрия (`shapely.geometry.shape`). Предполага се, че тази геометрия е в EPSG:4326.
                *   **Репроектиране** на Shapely геометрията към **EPSG:7801** чрез `shapely.ops.transform` и предварително дефинирания `pyproj.Transformer`.
                *   **Проверка за пресичане:** Използване на метода `intersects()` на Shapely за проверка дали **репроектираната геометрия на обекта (EPSG:7801)** се пресича с изчислената **геометрия на границата (също в EPSG:7801)**.
                *   **Вмъкване в базата данни (ако се пресичат):**
                    *   Конвертиране на **репроектираната (EPSG:7801)** Shapely геометрия обратно във WKT формат (`feature_geom.wkt`).
                    *   Изпълнение на `INSERT` SQL заявка в `bulgaria_buildings` (дефинирана от `target_table`):
                        *   Използване на `ST_GeomFromText(%s, 7801)` за създаване на геометрията от WKT **директно в EPSG:7801**.
                        *   Включване на `WHERE NOT EXISTS` подзаявка, използваща **`ST_Equals`**, за да се предотврати вмъкването на обекти, чиято геометрия е пространствено идентична на вече съществуваща **(проверката се извършва в EPSG:7801)**.
                    *   Ако `cursor.rowcount` е по-голямо от 0, увеличаване на брояча `inserted_count`.
                *   **Пропускане:** Ако геометрията на обекта не се пресича с границата, пропускаме.
            *   Обработка на потенциални грешки по време на JSON разбор, Unicode декодиране, действия с Shapely геометрия (`ShapelyError`, `ValueError`, `TypeError`). Отпечатване на грешка и продължаване към следващия ред.
        *   **Потвърждаване на транзакции на партиди (Batch Commits):** След обработката на всеки ред (ако е направен опит за вмъкване), проверка дали броят на извикванията към базата данни (`processed_count - skipped_count`) е кратен на `commit_batch_size` (1000). Ако е така, потвърждаване на текущата транзакция и отпечатване на прогреса.
    *   **Финално потвърждаване (за файл):** След преминаване през всички редове във файла, се потвърждава последната партида вмъквания за този файл.
    *   Отпечатва се обощение за завършения файл (обработени, пропуснати, вмъкнати) и времето, отнело за обработка на файла.

   Грешки, които се обработват

    *   Обработка на потенциални `psycopg2.Error` (грешки в базата данни) и общи `Exception` в `process_and_insert_data`, връщане на транзакцията (`rollback`), ако е необходимо. Затваряне на курсора в `finally` блок.
    *   Обработка на `FileNotFoundError` и `gzip.BadGzipFile` за текущия файл, отпечатване на грешка и продължаване към следващия файл (връщане на транзакцията, ако е необходимо за BadGzipFile).

6.  **Финално отчитане:** След обработване на всички файлове, отпечатване на общия брой вмъкнати обекти от всички файлове и общото време за изпълнение.
7.  **Обработка на грешки (Main):** Прихващане на потенциални `psycopg2.OperationalError` по време на първоначалното свързване и общи `Exception` по време на основното изпълнение. Връщане на транзакцията (`rollback`), ако съществува връзка.
8.  **Почистване:** Затваряне на връзката с базата данни в `finally` блок.

## Източник на данните

Данните за сгради се изтеглят от проекта на Microsoft [Global ML Building Footprints](https://github.com/microsoft/GlobalMLBuildingFootprints). Връзките за изтегляне са достъпни на:

https://minedbuildings.z5.web.core.windows.net/global-buildings/dataset-links.csv

Списъкът с файлове за България се поддържа в `input.txt` и се изтеглят автоматично в папка `IN/`.

За автоматично изтегляне и обновяване на списъка с файлове използвайте един от следните скриптове:
- `download_sofia_buildings.py` (платформено-независим, изисква Python и requests)
- `download_sofia_buildings.ps1` (PowerShell, работи на Windows и macOS/pwsh)

И двата скрипта:
- Дърпат dataset-links.csv от официалния URL
- Отсяват само записите за България (по името)
- Обновяват input.txt
- Теглят всички файлове в IN/
- input.txt се обновява само с успешно изтеглените файлове

## Съпоставка на пространствени операции: PostGIS (ST_) и Shapely

Тъй като ии Shapely и PostGIS стъпват на 

| PostGIS (ST_) функция      | Shapely функция/метод      | Описание                                  |
|---------------------------|----------------------------|--------------------------------------------|
| ST_Intersects(a, b)       | a.intersects(b)            | Проверява дали два обекта се пресичат      |
| ST_Within(a, b)           | a.within(b)                | Проверява дали a е изцяло в b              |
| ST_Contains(a, b)         | a.contains(b)              | Проверява дали a съдържа b                 |
| ST_Equals(a, b)           | a.equals(b)                | Проверява дали геометриите са идентични    |
| ST_Touches(a, b)          | a.touches(b)               | Проверява дали обектите се докосват        |
| ST_Disjoint(a, b)         | a.disjoint(b)              | Проверява дали са напълно отделни (без общи точки) |
| ST_Overlaps(a, b)         | a.overlaps(b)              | Проверява дали (поне частично) се припокриват   |
| ST_Distance(a, b)         | a.distance(b)              | Евклидово разстояние между геометрични обекти                 |
| ST_Buffer(a, r)           | a.buffer(r)                | Буфериране (разширяване/ограждане) на обект |
| ST_Area(a)                | a.area                     | Пресмятане площ на обекта                                    |
| ST_Length(a)              | a.length                   | Пресмятане дължина на линия/полигон                          |
| ST_Centroid(a)            | a.centroid                 | Изчислява центроид на обекта                      |

> Забележка: В Shapely всички операции са методи на обектите (например: poly1.intersects(poly2)), докато в PostGIS са функции с префикс ST_.

## Файлове
- `create_bulgaria_buildings_table.sql` – DDL за създаване на таблицата и индекса.
- `adm_rayoni_dump.sql` – SQL dump с административните райони.
- `import_sofia_buildings.py` – Основната програма за наливане на данните в базата.
- `input.txt` – Списък с източници на GeoJSONL файлове.
- `IN/` – Папка, в която се поставят изтеглените .gz файлове с геометрични данни за сгради.
- `download_bulgaria_buildings.py` – Python скрипт за автоматично изтегляне на данните.
- `download_bulgaria_buildings.ps1` – PowerShell скрипт за автоматично изтегляне на данните.

## Изисквания
- PostgreSQL с PostGIS (и настроен за връзка към него .env файл)
- Python 3.11+ с библиотеки: psycopg2, gzip, shapely, python-dotenv, requests
- (по избор) PowerShell (Windows/macOS) за .ps1 скрипта

## Изпълнение
1. Създайте таблицата с `create_bulgaria_buildings_table.sql`.
2. Възстановете архива на административните райони с помощта на `adm_rayoni_dump.sql`.
3. Използвайте един от скриптовете за изтегляне, за да попълните IN/ с .gz файловете.
4. Настройте .env файл с достъп до базата данни. В случая го търси в горната спрямо проекта папка.
5. Стартирайте `import_sofia_buildings.py`.

## Резултат

В базата данни следва да се появи има таблица с всички сгради, които попадат в административните граници на София, подходяща за пространствени анализи и визуализация.
